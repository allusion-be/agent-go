// Do NOT edit this file. It was automatically generated by https://github.com/aviate-labs/agent-go.
module T {
    public type Tokens = { e8s : Nat64 };
    public type TimeStamp = { timestamp_nanos : Nat64 };
    public type AccountIdentifier = Blob;
    public type SubAccount = Blob;
    public type BlockIndex = Nat64;
    public type Transaction = { memo : T.Memo; icrc1_memo : ?Blob; operation : ?T.Operation; created_at_time : T.TimeStamp };
    public type Memo = Nat64;
    public type TransferArgs = { memo : T.Memo; amount : T.Tokens; fee : T.Tokens; from_subaccount : ?T.SubAccount; to : T.AccountIdentifier; created_at_time : ?T.TimeStamp };
    public type TransferError = { #BadFee : { expected_fee : T.Tokens }; #InsufficientFunds : { balance : T.Tokens }; #TxTooOld : { allowed_window_nanos : Nat64 }; #TxCreatedInFuture : (); #TxDuplicate : { duplicate_of : T.BlockIndex } };
    public type TransferResult = { #Ok : T.BlockIndex; #Err : T.TransferError };
    public type AccountBalanceArgs = { account : T.AccountIdentifier };
    public type TransferFeeArg = {  };
    public type TransferFee = { transfer_fee : T.Tokens };
    public type GetBlocksArgs = { start : T.BlockIndex; length : Nat64 };
    public type Operation = { #Mint : { to : T.AccountIdentifier; amount : T.Tokens }; #Burn : { from : T.AccountIdentifier; spender : ?T.AccountIdentifier; amount : T.Tokens }; #Transfer : { from : T.AccountIdentifier; to : T.AccountIdentifier; amount : T.Tokens; fee : T.Tokens; spender : ?[Nat8] }; #Approve : { from : T.AccountIdentifier; spender : T.AccountIdentifier; allowance_e8s : Int; allowance : T.Tokens; fee : T.Tokens; expires_at : ?T.TimeStamp; expected_allowance : ?T.Tokens } };
    public type Block = { parent_hash : ?Blob; transaction : T.Transaction; timestamp : T.TimeStamp };
    public type BlockRange = { blocks : [T.Block] };
    public type QueryArchiveError = { #BadFirstBlockIndex : { requested_index : T.BlockIndex; first_valid_index : T.BlockIndex }; #Other : { error_code : Nat64; error_message : Text } };
    public type QueryArchiveResult = { #Ok : T.BlockRange; #Err : T.QueryArchiveError };
    public type QueryArchiveFn = { /* func */ };
    public type QueryBlocksResponse = { chain_length : Nat64; certificate : ?Blob; blocks : [T.Block]; first_block_index : T.BlockIndex; archived_blocks : [T.ArchivedBlocksRange] };
    public type ArchivedBlocksRange = { start : T.BlockIndex; length : Nat64; callback : T.QueryArchiveFn };
    public type ArchivedEncodedBlocksRange = { callback : { /* func */ }; start : Nat64; length : Nat64 };
    public type QueryEncodedBlocksResponse = { certificate : ?Blob; blocks : [Blob]; chain_length : Nat64; first_block_index : Nat64; archived_blocks : [T.ArchivedEncodedBlocksRange] };
    public type Archive = { canister_id : Principal };
    public type Archives = { archives : [T.Archive] };
    public type Duration = { secs : Nat64; nanos : Nat32 };
    public type ArchiveOptions = { trigger_threshold : Nat64; num_blocks_to_archive : Nat64; node_max_memory_size_bytes : ?Nat64; max_message_size_bytes : ?Nat64; controller_id : Principal; more_controller_ids : ?[Principal]; cycles_for_archive_creation : ?Nat64; max_transactions_per_response : ?Nat64 };
    public type TextAccountIdentifier = Text;
    public type SendArgs = { memo : T.Memo; amount : T.Tokens; fee : T.Tokens; from_subaccount : ?T.SubAccount; to : T.TextAccountIdentifier; created_at_time : ?T.TimeStamp };
    public type AccountBalanceArgsDfx = { account : T.TextAccountIdentifier };
    public type FeatureFlags = { icrc2 : Bool };
    public type InitArgs = { minting_account : T.TextAccountIdentifier; icrc1_minting_account : ?T.Account; initial_values : [(T.TextAccountIdentifier, T.Tokens)]; max_message_size_bytes : ?Nat64; transaction_window : ?T.Duration; archive_options : ?T.ArchiveOptions; send_whitelist : [Principal]; transfer_fee : ?T.Tokens; token_symbol : ?Text; token_name : ?Text; feature_flags : ?T.FeatureFlags; maximum_number_of_accounts : ?Nat64; accounts_overflow_trim_quantity : ?Nat64 };
    public type Icrc1BlockIndex = Nat;
    public type Icrc1Timestamp = Nat64;
    public type Icrc1Tokens = Nat;
    public type Account = { owner : Principal; subaccount : ?T.SubAccount };
    public type TransferArg = { from_subaccount : ?T.SubAccount; to : T.Account; amount : T.Icrc1Tokens; fee : ?T.Icrc1Tokens; memo : ?Blob; created_at_time : ?T.Icrc1Timestamp };
    public type Icrc1TransferError = { #BadFee : { expected_fee : T.Icrc1Tokens }; #BadBurn : { min_burn_amount : T.Icrc1Tokens }; #InsufficientFunds : { balance : T.Icrc1Tokens }; #TooOld; #CreatedInFuture : { ledger_time : Nat64 }; #TemporarilyUnavailable; #Duplicate : { duplicate_of : T.Icrc1BlockIndex }; #GenericError : { error_code : Nat; message : Text } };
    public type Icrc1TransferResult = { #Ok : T.Icrc1BlockIndex; #Err : T.Icrc1TransferError };
    public type Value = { #Nat : Nat; #Int : Int; #Text : Text; #Blob : Blob };
    public type UpgradeArgs = { maximum_number_of_accounts : ?Nat64; icrc1_minting_account : ?T.Account; feature_flags : ?T.FeatureFlags };
    public type LedgerCanisterPayload = { #Init : T.InitArgs; #Upgrade : ?T.UpgradeArgs };
    public type ApproveArgs = { from_subaccount : ?T.SubAccount; spender : T.Account; amount : T.Icrc1Tokens; expected_allowance : ?T.Icrc1Tokens; expires_at : ?T.Icrc1Timestamp; fee : ?T.Icrc1Tokens; memo : ?Blob; created_at_time : ?T.Icrc1Timestamp };
    public type ApproveError = { #BadFee : { expected_fee : T.Icrc1Tokens }; #InsufficientFunds : { balance : T.Icrc1Tokens }; #AllowanceChanged : { current_allowance : T.Icrc1Tokens }; #Expired : { ledger_time : Nat64 }; #TooOld; #CreatedInFuture : { ledger_time : Nat64 }; #Duplicate : { duplicate_of : T.Icrc1BlockIndex }; #TemporarilyUnavailable; #GenericError : { error_code : Nat; message : Text } };
    public type ApproveResult = { #Ok : T.Icrc1BlockIndex; #Err : T.ApproveError };
    public type AllowanceArgs = { account : T.Account; spender : T.Account };
    public type Allowance = { allowance : T.Icrc1Tokens; expires_at : ?T.Icrc1Timestamp };
    public type TransferFromArgs = { spender_subaccount : ?T.SubAccount; from : T.Account; to : T.Account; amount : T.Icrc1Tokens; fee : ?T.Icrc1Tokens; memo : ?Blob; created_at_time : ?T.Icrc1Timestamp };
    public type TransferFromResult = { #Ok : T.Icrc1BlockIndex; #Err : T.TransferFromError };
    public type TransferFromError = { #BadFee : { expected_fee : T.Icrc1Tokens }; #BadBurn : { min_burn_amount : T.Icrc1Tokens }; #InsufficientFunds : { balance : T.Icrc1Tokens }; #InsufficientAllowance : { allowance : T.Icrc1Tokens }; #TooOld; #CreatedInFuture : { ledger_time : T.Icrc1Timestamp }; #Duplicate : { duplicate_of : T.Icrc1BlockIndex }; #TemporarilyUnavailable; #GenericError : { error_code : Nat; message : Text } };
};
