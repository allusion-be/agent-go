// Do NOT edit this file. It was automatically generated by https://github.com/aviate-labs/agent-go.
package ic_test

import (
	"github.com/aviate-labs/agent-go"
	"github.com/aviate-labs/agent-go/candid/idl"
	"github.com/aviate-labs/agent-go/mock"
	"github.com/aviate-labs/agent-go/principal"
	"net/http/httptest"
	"net/url"
	"testing"

	"github.com/aviate-labs/agent-go/ic/ic"
)

// Test_BitcoinGetBalance tests the "bitcoin_get_balance" method on the "ic" canister.
func Test_BitcoinGetBalance(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "bitcoin_get_balance",
			Arguments: []any{new(ic.BitcoinGetBalanceArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new(ic.Satoshi)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.BitcoinGetBalanceArgs{
		*new(string),
		ic.BitcoinNetwork{
			Mainnet: new(idl.Null),
		},
		*new(*uint32),
	}
	if _, err := a.BitcoinGetBalance(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_BitcoinGetBalanceQuery tests the "bitcoin_get_balance_query" method on the "ic" canister.
func Test_BitcoinGetBalanceQuery(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "bitcoin_get_balance_query",
			Arguments: []any{new(ic.BitcoinGetBalanceQueryArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new(ic.Satoshi)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.BitcoinGetBalanceQueryArgs{
		*new(string),
		ic.BitcoinNetwork{
			Mainnet: new(idl.Null),
		},
		*new(*uint32),
	}
	if _, err := a.BitcoinGetBalanceQuery(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_BitcoinGetCurrentFeePercentiles tests the "bitcoin_get_current_fee_percentiles" method on the "ic" canister.
func Test_BitcoinGetCurrentFeePercentiles(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "bitcoin_get_current_fee_percentiles",
			Arguments: []any{new(ic.BitcoinGetCurrentFeePercentilesArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new([]ic.MillisatoshiPerByte)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.BitcoinGetCurrentFeePercentilesArgs{
		ic.BitcoinNetwork{
			Mainnet: new(idl.Null),
		},
	}
	if _, err := a.BitcoinGetCurrentFeePercentiles(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_BitcoinGetUtxos tests the "bitcoin_get_utxos" method on the "ic" canister.
func Test_BitcoinGetUtxos(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "bitcoin_get_utxos",
			Arguments: []any{new(ic.BitcoinGetUtxosArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.BitcoinGetUtxosResult{
					[]ic.Utxo{{
						ic.Outpoint{
							*new([]byte),
							*new(uint32),
						},
						*new(uint64),
						*new(uint32),
					}},
					*new([]byte),
					*new(uint32),
					*new(*[]byte),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.BitcoinGetUtxosArgs{
		*new(string),
		ic.BitcoinNetwork{
			Mainnet: new(idl.Null),
		},
		*new(*struct {
			MinConfirmations *uint32 `ic:"min_confirmations,variant"`
			Page             *[]byte `ic:"page,variant"`
		}),
	}
	if _, err := a.BitcoinGetUtxos(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_BitcoinGetUtxosQuery tests the "bitcoin_get_utxos_query" method on the "ic" canister.
func Test_BitcoinGetUtxosQuery(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "bitcoin_get_utxos_query",
			Arguments: []any{new(ic.BitcoinGetUtxosQueryArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.BitcoinGetUtxosQueryResult{
					[]ic.Utxo{{
						ic.Outpoint{
							*new([]byte),
							*new(uint32),
						},
						*new(uint64),
						*new(uint32),
					}},
					*new([]byte),
					*new(uint32),
					*new(*[]byte),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.BitcoinGetUtxosQueryArgs{
		*new(string),
		ic.BitcoinNetwork{
			Mainnet: new(idl.Null),
		},
		*new(*struct {
			MinConfirmations *uint32 `ic:"min_confirmations,variant"`
			Page             *[]byte `ic:"page,variant"`
		}),
	}
	if _, err := a.BitcoinGetUtxosQuery(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_BitcoinSendTransaction tests the "bitcoin_send_transaction" method on the "ic" canister.
func Test_BitcoinSendTransaction(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "bitcoin_send_transaction",
			Arguments: []any{new(ic.BitcoinSendTransactionArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.BitcoinSendTransactionArgs{
		*new([]byte),
		ic.BitcoinNetwork{
			Mainnet: new(idl.Null),
		},
	}
	if err := a.BitcoinSendTransaction(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CanisterInfo tests the "canister_info" method on the "ic" canister.
func Test_CanisterInfo(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "canister_info",
			Arguments: []any{new(ic.CanisterInfoArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.CanisterInfoResult{
					*new(uint64),
					[]ic.Change{{
						*new(uint64),
						*new(uint64),
						ic.ChangeOrigin{
							FromUser: idl.Ptr(struct {
								UserId principal.Principal `ic:"user_id" json:"user_id"`
							}{
								*new(principal.Principal),
							}),
						},
						ic.ChangeDetails{
							Creation: idl.Ptr(struct {
								Controllers []principal.Principal `ic:"controllers" json:"controllers"`
							}{
								[]principal.Principal{*new(principal.Principal)},
							}),
						},
					}},
					*new(*[]byte),
					[]principal.Principal{*new(principal.Principal)},
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.CanisterInfoArgs{
		*new(principal.Principal),
		*new(*uint64),
	}
	if _, err := a.CanisterInfo(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CanisterStatus tests the "canister_status" method on the "ic" canister.
func Test_CanisterStatus(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "canister_status",
			Arguments: []any{new(ic.CanisterStatusArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.CanisterStatusResult{
					struct {
						Running  *idl.Null `ic:"running,variant"`
						Stopping *idl.Null `ic:"stopping,variant"`
						Stopped  *idl.Null `ic:"stopped,variant"`
					}{
						Running: new(idl.Null),
					},
					ic.DefiniteCanisterSettings{
						[]principal.Principal{*new(principal.Principal)},
						idl.NewNat(uint(0)),
						idl.NewNat(uint(0)),
						idl.NewNat(uint(0)),
						idl.NewNat(uint(0)),
					},
					*new(*[]byte),
					idl.NewNat(uint(0)),
					idl.NewNat(uint(0)),
					idl.NewNat(uint(0)),
					idl.NewNat(uint(0)),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.CanisterStatusArgs{
		*new(principal.Principal),
	}
	if _, err := a.CanisterStatus(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ClearChunkStore tests the "clear_chunk_store" method on the "ic" canister.
func Test_ClearChunkStore(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "clear_chunk_store",
			Arguments: []any{new(ic.ClearChunkStoreArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.ClearChunkStoreArgs{
		*new(principal.Principal),
	}
	if err := a.ClearChunkStore(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_CreateCanister tests the "create_canister" method on the "ic" canister.
func Test_CreateCanister(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "create_canister",
			Arguments: []any{new(ic.CreateCanisterArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.CreateCanisterResult{
					*new(principal.Principal),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.CreateCanisterArgs{
		*new(*ic.CanisterSettings),
		*new(*uint64),
	}
	if _, err := a.CreateCanister(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_DeleteCanister tests the "delete_canister" method on the "ic" canister.
func Test_DeleteCanister(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "delete_canister",
			Arguments: []any{new(ic.DeleteCanisterArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.DeleteCanisterArgs{
		*new(principal.Principal),
	}
	if err := a.DeleteCanister(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_DepositCycles tests the "deposit_cycles" method on the "ic" canister.
func Test_DepositCycles(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "deposit_cycles",
			Arguments: []any{new(ic.DepositCyclesArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.DepositCyclesArgs{
		*new(principal.Principal),
	}
	if err := a.DepositCycles(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_EcdsaPublicKey tests the "ecdsa_public_key" method on the "ic" canister.
func Test_EcdsaPublicKey(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "ecdsa_public_key",
			Arguments: []any{new(ic.EcdsaPublicKeyArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.EcdsaPublicKeyResult{
					*new([]byte),
					*new([]byte),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.EcdsaPublicKeyArgs{
		*new(*ic.CanisterId),
		[][]byte{*new([]byte)},
		struct {
			Curve ic.EcdsaCurve `ic:"curve" json:"curve"`
			Name  string        `ic:"name" json:"name"`
		}{
			ic.EcdsaCurve{
				Secp256k1: new(idl.Null),
			},
			*new(string),
		},
	}
	if _, err := a.EcdsaPublicKey(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_HttpRequest tests the "http_request" method on the "ic" canister.
func Test_HttpRequest(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "http_request",
			Arguments: []any{new(ic.HttpRequestArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.HttpRequestResult{
					idl.NewNat(uint(0)),
					[]ic.HttpHeader{{
						*new(string),
						*new(string),
					}},
					*new([]byte),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.HttpRequestArgs{
		*new(string),
		*new(*uint64),
		struct {
			Get  *idl.Null `ic:"get,variant"`
			Head *idl.Null `ic:"head,variant"`
			Post *idl.Null `ic:"post,variant"`
		}{
			Get: new(idl.Null),
		},
		[]ic.HttpHeader{{
			*new(string),
			*new(string),
		}},
		*new(*[]byte),
		*new(*struct {
			Function struct { /* NOT SUPPORTED */
			} `ic:"function" json:"function"`
			Context []byte `ic:"context" json:"context"`
		}),
	}
	if _, err := a.HttpRequest(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_InstallChunkedCode tests the "install_chunked_code" method on the "ic" canister.
func Test_InstallChunkedCode(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "install_chunked_code",
			Arguments: []any{new(ic.InstallChunkedCodeArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.InstallChunkedCodeArgs{
		ic.CanisterInstallMode{
			Install: new(idl.Null),
		},
		*new(principal.Principal),
		*new(*ic.CanisterId),
		[]ic.ChunkHash{{
			*new([]byte),
		}},
		*new([]byte),
		*new([]byte),
		*new(*uint64),
	}
	if err := a.InstallChunkedCode(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_InstallCode tests the "install_code" method on the "ic" canister.
func Test_InstallCode(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "install_code",
			Arguments: []any{new(ic.InstallCodeArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.InstallCodeArgs{
		ic.CanisterInstallMode{
			Install: new(idl.Null),
		},
		*new(principal.Principal),
		*new([]byte),
		*new([]byte),
		*new(*uint64),
	}
	if err := a.InstallCode(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_NodeMetricsHistory tests the "node_metrics_history" method on the "ic" canister.
func Test_NodeMetricsHistory(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "node_metrics_history",
			Arguments: []any{new(ic.NodeMetricsHistoryArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new([]struct {
					TimestampNanos uint64           `ic:"timestamp_nanos" json:"timestamp_nanos"`
					NodeMetrics    []ic.NodeMetrics `ic:"node_metrics" json:"node_metrics"`
				})}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.NodeMetricsHistoryArgs{
		*new(principal.Principal),
		*new(uint64),
	}
	if _, err := a.NodeMetricsHistory(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ProvisionalCreateCanisterWithCycles tests the "provisional_create_canister_with_cycles" method on the "ic" canister.
func Test_ProvisionalCreateCanisterWithCycles(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "provisional_create_canister_with_cycles",
			Arguments: []any{new(ic.ProvisionalCreateCanisterWithCyclesArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.ProvisionalCreateCanisterWithCyclesResult{
					*new(principal.Principal),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.ProvisionalCreateCanisterWithCyclesArgs{
		*new(*idl.Nat),
		*new(*ic.CanisterSettings),
		*new(*ic.CanisterId),
		*new(*uint64),
	}
	if _, err := a.ProvisionalCreateCanisterWithCycles(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_ProvisionalTopUpCanister tests the "provisional_top_up_canister" method on the "ic" canister.
func Test_ProvisionalTopUpCanister(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "provisional_top_up_canister",
			Arguments: []any{new(ic.ProvisionalTopUpCanisterArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.ProvisionalTopUpCanisterArgs{
		*new(principal.Principal),
		idl.NewNat(uint(0)),
	}
	if err := a.ProvisionalTopUpCanister(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_RawRand tests the "raw_rand" method on the "ic" canister.
func Test_RawRand(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "raw_rand",
			Arguments: []any{},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new([]byte)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	if _, err := a.RawRand(); err != nil {
		t.Fatal(err)
	}

}

// Test_SignWithEcdsa tests the "sign_with_ecdsa" method on the "ic" canister.
func Test_SignWithEcdsa(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "sign_with_ecdsa",
			Arguments: []any{new(ic.SignWithEcdsaArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{ic.SignWithEcdsaResult{
					*new([]byte),
				}}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.SignWithEcdsaArgs{
		*new([]byte),
		[][]byte{*new([]byte)},
		struct {
			Curve ic.EcdsaCurve `ic:"curve" json:"curve"`
			Name  string        `ic:"name" json:"name"`
		}{
			ic.EcdsaCurve{
				Secp256k1: new(idl.Null),
			},
			*new(string),
		},
	}
	if _, err := a.SignWithEcdsa(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_StartCanister tests the "start_canister" method on the "ic" canister.
func Test_StartCanister(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "start_canister",
			Arguments: []any{new(ic.StartCanisterArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.StartCanisterArgs{
		*new(principal.Principal),
	}
	if err := a.StartCanister(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_StopCanister tests the "stop_canister" method on the "ic" canister.
func Test_StopCanister(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "stop_canister",
			Arguments: []any{new(ic.StopCanisterArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.StopCanisterArgs{
		*new(principal.Principal),
	}
	if err := a.StopCanister(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_StoredChunks tests the "stored_chunks" method on the "ic" canister.
func Test_StoredChunks(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "stored_chunks",
			Arguments: []any{new(ic.StoredChunksArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new([]ic.ChunkHash)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.StoredChunksArgs{
		*new(principal.Principal),
	}
	if _, err := a.StoredChunks(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_UninstallCode tests the "uninstall_code" method on the "ic" canister.
func Test_UninstallCode(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "uninstall_code",
			Arguments: []any{new(ic.UninstallCodeArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.UninstallCodeArgs{
		*new(principal.Principal),
		*new(*uint64),
	}
	if err := a.UninstallCode(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_UpdateSettings tests the "update_settings" method on the "ic" canister.
func Test_UpdateSettings(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "update_settings",
			Arguments: []any{new(ic.UpdateSettingsArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.UpdateSettingsArgs{
		*new(principal.Principal),
		ic.CanisterSettings{
			*new(*[]principal.Principal),
			*new(*idl.Nat),
			*new(*idl.Nat),
			*new(*idl.Nat),
			*new(*idl.Nat),
		},
		*new(*uint64),
	}
	if err := a.UpdateSettings(a0); err != nil {
		t.Fatal(err)
	}

}

// Test_UploadChunk tests the "upload_chunk" method on the "ic" canister.
func Test_UploadChunk(t *testing.T) {
	a, err := newAgent([]mock.Method{
		{
			Name:      "upload_chunk",
			Arguments: []any{new(ic.UploadChunkArgs)},
			Handler: func(request mock.Request) ([]any, error) {
				return []any{*new(ic.ChunkHash)}, nil
			},
		},
	})
	if err != nil {
		t.Fatal(err)
	}

	var a0 = ic.UploadChunkArgs{
		*new(principal.Principal),
		*new([]byte),
	}
	if _, err := a.UploadChunk(a0); err != nil {
		t.Fatal(err)
	}

}

// newAgent creates a new agent with the given (mock) methods.
// Runs a mock replica in the background.
func newAgent(methods []mock.Method) (*ic.Agent, error) {
	replica := mock.NewReplica()
	canisterId := principal.Principal{Raw: []byte("ic")}
	replica.AddCanister(canisterId, methods)
	s := httptest.NewServer(replica)
	u, _ := url.Parse(s.URL)
	a, err := ic.NewAgent(canisterId, agent.Config{
		ClientConfig: &agent.ClientConfig{Host: u},
		FetchRootKey: true,
	})
	if err != nil {
		return nil, err
	}
	return a, nil
}
