package bls

import (
	"encoding/hex"
	bls "github.com/consensys/gnark-crypto/ecc/bls12-381"
	"github.com/consensys/gnark-crypto/ecc/bls12-381/fr"
	"math/big"
)

const (
	dstG1 = "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_"
)

type PublicKey bls.G2Affine

// PublicKeyFromBytes returns a PublicKey from a byte slice.
func PublicKeyFromBytes(b []byte) (*PublicKey, error) {
	var pub bls.G2Affine
	err := pub.Unmarshal(b)
	if err != nil {
		return nil, err
	}
	res := PublicKey(pub)
	return &res, err
}

// PublicKeyFromHexString returns a PublicKey from a hex string.
func PublicKeyFromHexString(s string) (*PublicKey, error) {
	b, err := hex.DecodeString(s)
	if err != nil {
		return nil, err
	}
	return PublicKeyFromBytes(b)
}

type SecretKey fr.Element

// NewSecretKeyByCSPRNG returns a new SecretKey generated by CSPRNG.
func NewSecretKeyByCSPRNG() *SecretKey {
	var sk fr.Element
	_, err := sk.SetRandom()
	if err != nil {
		return nil
	}
	res := SecretKey(sk)
	return &res
}

func (sk *SecretKey) PublicKey() *PublicKey {
	_, _, _, g2Gen := bls.Generators()

	el := fr.Element(*sk)
	v := el.BigInt(big.NewInt(0))

	pk := g2Gen.ScalarMultiplication(&g2Gen, v)
	return (*PublicKey)(pk)
}

func (sk *SecretKey) Sign(msg []byte) *Signature {
	el := fr.Element(*sk)
	v := el.BigInt(big.NewInt(0))
	g1, _ := bls.HashToG1(msg, []byte(dstG1))
	sig := g1.ScalarMultiplication(&g1, v)
	return (*Signature)(sig)
}

type Signature bls.G1Affine

// SignatureFromBytes returns a Signature from a byte slice.
func SignatureFromBytes(b []byte) (*Signature, error) {
	var sig bls.G1Affine
	_, err := sig.SetBytes(b)
	if err != nil {
		return nil, err
	}
	res := Signature(sig)
	return &res, err
}

// SignatureFromHexString returns a Signature from a hex string.
func SignatureFromHexString(s string) (*Signature, error) {
	b, err := hex.DecodeString(s)
	if err != nil {
		return nil, err
	}
	return SignatureFromBytes(b)
}

func (sig *Signature) Verify(pk *PublicKey, msg []byte) bool {
	g1, _ := bls.HashToG1(msg, []byte(dstG1))
	_, _, _, g2 := bls.Generators()
	var g2n bls.G2Affine
	g2n.Neg(&g2)

	valid, err := bls.PairingCheck([]bls.G1Affine{bls.G1Affine(*sig), g1}, []bls.G2Affine{g2n, bls.G2Affine(*pk)})
	if err != nil {
		return false
	}
	return valid
}
