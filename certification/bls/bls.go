package bls

import (
	"encoding/hex"
	"github.com/consensys/gnark-crypto/ecc/bls12-381"
	"github.com/consensys/gnark-crypto/ecc/bls12-381/fr"
	"math/big"
)

const dstG1 = "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_"

var (
	g2, g2Gen bls12381.G2Affine
)

func init() {
	_, _, _, g2Gen = bls12381.Generators()
	g2.Neg(&g2Gen)
}

type PublicKey bls12381.G2Affine

// PublicKeyFromBytes returns a PublicKey from a byte slice.
func PublicKeyFromBytes(b []byte) (*PublicKey, error) {
	var g2 bls12381.G2Affine
	if err := g2.Unmarshal(b); err != nil {
		return nil, err
	}
	return (*PublicKey)(&g2), nil
}

// PublicKeyFromHexString returns a PublicKey from a hex string.
func PublicKeyFromHexString(s string) (*PublicKey, error) {
	raw, err := hex.DecodeString(s)
	if err != nil {
		return nil, err
	}
	return PublicKeyFromBytes(raw)
}

type SecretKey fr.Element

// NewSecretKeyByCSPRNG returns a new SecretKey generated by CSPRNG.
func NewSecretKeyByCSPRNG() *SecretKey {
	var e fr.Element
	if _, err := e.SetRandom(); err != nil {
		return nil
	}
	return (*SecretKey)(&e)
}

func (sk *SecretKey) GetPublicKey() *PublicKey {
	e := fr.Element(*sk)
	pk := g2Gen.ScalarMultiplication(
		&g2Gen,
		e.BigInt(big.NewInt(0)),
	)
	return (*PublicKey)(pk)
}

func (sk *SecretKey) Sign(msg []byte) *Signature {
	e := fr.Element(*sk)
	g1, _ := bls12381.HashToG1(msg, []byte(dstG1))
	sig := g1.ScalarMultiplication(
		&g1,
		e.BigInt(big.NewInt(0)),
	)
	return (*Signature)(sig)
}

type Signature bls12381.G1Affine

// SignatureFromBytes returns a Signature from a byte slice.
func SignatureFromBytes(b []byte) (*Signature, error) {
	var sig bls12381.G1Affine
	if _, err := sig.SetBytes(b); err != nil {
		return nil, err
	}
	return (*Signature)(&sig), nil
}

// SignatureFromHexString returns a Signature from a hex string.
func SignatureFromHexString(s string) (*Signature, error) {
	raw, err := hex.DecodeString(s)
	if err != nil {
		return nil, err
	}
	return SignatureFromBytes(raw)
}

// Verify returns true if the signature is valid for the message.
func (sig *Signature) Verify(pk *PublicKey, msg []byte) bool {
	g1, _ := bls12381.HashToG1(msg, []byte(dstG1))
	valid, err := bls12381.PairingCheck(
		[]bls12381.G1Affine{bls12381.G1Affine(*sig), g1},
		[]bls12381.G2Affine{g2, bls12381.G2Affine(*pk)})
	if err != nil {
		return false
	}
	return valid
}
